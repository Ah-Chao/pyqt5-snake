2019/05/14

现在已经完成了简单的贪吃蛇的游戏

我需要进行其自动的游戏过程

但这个过程需要抽象整个过程，那么这个过程应该是怎么样进行的，也就是说我应该怎么进行这个抽象过程

2019/05/14

来简化一下整个思考过程：

1. 游戏的状态空间包括蛇的位置，还有食物的位置

2. 可以进行的动作包括几个可以进行的动作


2019/05/14
定义了状态空间，也进行了这部分的编码

现在遇见的问题就是，我不知道怎么去实现这个宽度优先的搜索算法了
怎么保存已经走下来的路径？


2019/05/15
这里发现的一个问题，我好像没有实质的状态变化，
而且没办法实时到底发生了什么变化

2019/05/16
1. 列表的复制问题，直接带入使得原始列表也被改变
2. 内存占用挺大的，到100M了都，不清楚是不是完全这部分占用的
3. 目前已经可以保证程序可以运行，但宽度优先的搜索算法的确很吃力，
能够明显的看到他在搜索时候的停顿感
问题：
    如果gui的定时器没有在时间间隔内完成任务，
    那么他还会调用这个定时器吗？
   

下一步先调整一下，看看是不是能提供一些优化的算法

1. 将蛇头已经探索过的地方，放置到集合中,实现部分速度提升
基本上已经运行很平滑了
但是现在平均的游戏得分并不是非常高，
对应看了一下具体的书上的算法，完全复现了这个部分的代码，在代码逻辑上已经没有优化的可能性了
2. 使用其他算法，深度优先
实现了深度优先算法，他的平均得分是很高了，但是整体的感觉很奇怪
每次都是竖条的往一个地方走
3. 来试试启发式算法
第一版启发式函数，没有考虑柱面距离，直接使用欧式距离
然后他妈的，他自己久跟抽风了一样，瞎几把晃悠，就是不到食物那里去
我觉得应该是这个队列没弄好，虽然已经把这个优先级搞得排上去了，但是并不是针对他的动作

~~我仔细想了想，按说这个东西，就是我理解的，得用递归的形式，
但好像并没有，最后弄得这个队列我总感觉不对劲
现在它整体的流程我也不知道是怎么发生的，很尴尬。
包括我现在想想，最开始实现的宽度优先也是，他的动作是从上一个状态继承下来的嘛，我就感觉~~
想错了，我是把整个状态给放到队列里面了，并不是单个的动作

我把优先队列的排序弄反了，也就是说每次都是放的最差的，现在可以保证我这个游戏能按照我想的那样，按照距离进行搜索了
但整体上感觉，游戏还是会死
