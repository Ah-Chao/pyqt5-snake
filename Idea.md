2019/05/14

现在已经完成了简单的贪吃蛇的游戏

我需要进行其自动的游戏过程

但这个过程需要抽象整个过程，那么这个过程应该是怎么样进行的，也就是说我应该怎么进行这个抽象过程

2019/05/14

来简化一下整个思考过程：

1. 游戏的状态空间包括蛇的位置，还有食物的位置

2. 可以进行的动作包括几个可以进行的动作


2019/05/14
定义了状态空间，也进行了这部分的编码

现在遇见的问题就是，我不知道怎么去实现这个宽度优先的搜索算法了
怎么保存已经走下来的路径？


2019/05/15
这里发现的一个问题，我好像没有实质的状态变化，
而且没办法实时到底发生了什么变化

2019/05/16
1. 列表的复制问题，直接带入使得原始列表也被改变
2. 内存占用挺大的，到100M了都，不清楚是不是完全这部分占用的
3. 目前已经可以保证程序可以运行，但宽度优先的搜索算法的确很吃力，
能够明显的看到他在搜索时候的停顿感
问题：
    如果gui的定时器没有在时间间隔内完成任务，
    那么他还会调用这个定时器吗？
   

下一步先调整一下，看看是不是能提供一些优化的算法

1. 将蛇头已经探索过的地方，放置到集合中,实现部分速度提升
基本上已经运行很平滑了
但是现在平均的游戏得分并不是非常高，
对应看了一下具体的书上的算法，完全复现了这个部分的代码，在代码逻辑上已经没有优化的可能性了
2. 使用其他算法，深度优先
实现了深度优先算法，他的平均得分是很高了，但是整体的感觉很奇怪
每次都是竖条的往一个地方走
3. 来试试启发式算法
第一版启发式函数，没有考虑柱面距离，直接使用欧式距离
然后他妈的，他自己久跟抽风了一样，瞎几把晃悠，就是不到食物那里去
我觉得应该是这个队列没弄好，虽然已经把这个优先级搞得排上去了，但是并不是针对他的动作

~~我仔细想了想，按说这个东西，就是我理解的，得用递归的形式，
但好像并没有，最后弄得这个队列我总感觉不对劲
现在它整体的流程我也不知道是怎么发生的，很尴尬。
包括我现在想想，最开始实现的宽度优先也是，他的动作是从上一个状态继承下来的嘛，我就感觉~~
想错了，我是把整个状态给放到队列里面了，并不是单个的动作

我把优先队列的排序弄反了，也就是说每次都是放的最差的，现在可以保证我这个游戏能按照我想的那样，按照距离进行搜索了
但整体上感觉，游戏还是会死

有一些是那种，明显可以跳越过去的，有一些，我感觉是我程序的异常处理部分还是有bug

有个问题就是，我现在的设计耦合还是太严重了，我应该把蛇的设计从画板中抽离处理，这样才能保证后面我修改蛇，只需要给状态就可以，
反正就是画板不关我蛇的内容
这三个算法应该都是没有什么问题的，编程逻辑上

经过多次测试，发现他总是在一些不该死的地方死了，而且每次都是碰到了他的尾巴最后的地方，
我感觉感觉可能是因为两边的状态转移不太一致，就是在状态空间搜索的时候，他是没有撞的，但实际上后面撞了
这个地方麻烦了，感觉照常他不应该会出现这种情况的，
因为我每个步骤都进行了测试，应该是不可能出现这种情况的
严重的发现我没法对这个东西进行测试，完全没有办法复现
就是我没办法调试，我尼玛完全将就是瞎几把调的

2019/05/15
现在的一个尴尬的问题，就是说我游戏里面产生的进程，
我出错了把，比如说，但是结果呢，
我把那个部分拿出来，就发现他的运作过程不一样了
而且，我发现我的内存一直在增加，所以我很怀疑这个东西，存在内存泄露
我就感觉这个调试的过程非常费劲，你看为什么他们两个就不一样呢

如果我把这个发生碰撞的过程，重新复制到新的程序里面，
也不会发生碰撞

这就验证了我的想法，那就是说，可能我的状态里面存在一些内存泄漏
一些当时的节点并不是他该有的

经过一番检查之后，发现前面说的不对，他返回的路径没错
其搞到的路径也没错，就是这样，那么就是这整个算法错了


现在又出现了新的情况，那就是我把新的内容复制过来，
自动运行的过程，跟原始提供的思路一样，结果这会过去了，他妈的
而且，比较奇怪的是，明明开始的状态是4个点，结果碰撞了之后就变成5个点了

知道了，还是蛇增长部分的逻辑没有捋清楚
明天再弄这个

问题根源在于，在移动路径空了之后，其实这是刚刚吃完一个事物，
但蛇还没有变长，所以导致传输进去的状态少一个尾巴
但你这个时候还不知道要往那个方向走，所以你必须把这个状态增加
变到下一个状态里面
现在的修改就是这样的一个过程
与以往不同的就是，正常的寻路可能就是个走过去就行了，
但贪吃蛇不同， 你找到了地方，还要改变状态

2019/05/16
这次对于贪婪算法，添加了状态的增长，已经可以成功实现了
但是对于宽度优先和深度优先，应该也存在这种问题，还需要对代码进行修改



2019/05/16

对于版本控制这个部分，使用基本没什么作用，

对我来说就是个记录的过程，太尴尬了

2019/05/16

对于最后死亡的步骤，有的可能真的就死亡了，但是其实有挽救的措施

那么就得考虑：在我完成这个步骤之后，我还要将后续可能的状态在考虑一些，
保证他不会失败，一旦这种情况，我感觉就很难受了
这个得仔细考虑

另外，前面说过的，现在的代码，写的不好，

**调试的过程非常难受**，出现了问题基本上就是完全手动调
很多时候还没办法浮现原有的情况

到目前位置，给我最大的教训就是：
**列表的复制**，一定要copy，不要直接复制
另外，这种gui情况下， 他不会明显的报错，如果你没有异常处理，而且
你在大的代码下面弄这个东西还没有，必须在那个出毛病的代码块部分

可能我之前弄MFC的时候也遇见过，但记不得了。

最后就是内存的问题，为什么内存一直在增长，就是最直观的情况，
如果我挂了，我每次重新Q，他还是会增长，
这个情况，目前为止我还没想到好的办法

2019/05/16

现在把代码逻辑给改了很多，尽量保证了可以让代码精简，并且优美
能复用的，就复用

2019/05/16

刚才查了查内存泄漏相关的内容，
我感觉可能问题的地方，我在那个搜索的时候，
添加的父节点和子节点，
按说他们是自己释放的，
但是他们存在相互引用，导致最后他们之间就出现了没法释放，
可能是这个原因，但还需要探索

我尝试着用广度优先的搜索算法测试，
发现最后碰撞了之后，即使我一直按Q，虽然他是增长的
但按了多次之后，他就是那个数值了，也不会再增加了
所以说，到底是不是存在这个内存问题，还真不好说

刚才如果将程序锁死在不增长的情况，就发现，他的内存是在增长之后就定死在大致的一个范围
所以说应该是不存在内存泄漏的

再考虑，整个封装的内容，
这个程序怎么说， 
没法验证这种搜索算法是不是就对
毕竟这个东西就是这样的

后面的的话，要考虑考虑弄成我想象的那样，就是添加各种小物件，但这个内容就必须继续好好学习GUI编程了

而且，比较关键的是，虽然这个程序我弄完了，其实本质上，对于图像编程的部分，我基本什么也没弄
也就是说，还是不太理解，到底这个东西运作的过程，
如果最开始的时候，理解了这个，可能当时的那个bug就能更早的调试出来把。

我现在先把整个代码组织结构给分离出来，这样画图的部分自己就设计这部分内容了
而且搜索算法也不会跟蛇的状态绑定


2019/05/16
已经完成了全部的代码分离过程，但是实际上我觉得还有改进的空间
就是我感觉状态空间的代码跟蛇的代码有重复，可以用继承来完成这部分工作的

而且给游戏做状态的类完全可以继承一个
就是类的函数那里，有重复，封装性我也不知道是不是够好
但现在已经完成了分离，然后游戏状态跟之前修改前一模一样

